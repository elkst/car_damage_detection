# Импортируем нужные библиотеки
# YOLO для работы с моделью детекции объектов
# torch для работы с GPU
from ultralytics import YOLO
import torch


# Основная функция для обучения модели
def main():
    # Проверяем есть ли GPU для ускорения обучения
    # Если GPU есть - используем его, если нет - CPU
    device = 'cuda' if torch.cuda.is_available() else 'cpu'
    print(f"Using device: {device}")

    # Если GPU доступен, показываем информацию о нем
    if device == 'cuda':
        print(f"GPU: {torch.cuda.get_device_name(0)}")
        print(f"CUDA version: {torch.version.cuda}")

    # Загружаем готовую модель YOLOv8 среднего размера
    # Эта модель уже обучена на общем наборе данных
    # Мы будем доучивать ее для наших целей
    model = YOLO('yolov8m.pt')

    # Настраиваем параметры обучения модели
    training_config = {
        'data': 'data.yaml',  # Файл с описанием данных (пути к картинкам и классы)
        'epochs': 20,  # Сколько раз модель увидит все данные
        'imgsz': 640,  # Размер картинок для обучения
        'batch': 16,  # Сколько картинок обрабатывать за один раз
        'device': device,  # На чем обучать (GPU или CPU)
        'workers': 4,  # Сколько процессов загружать данные
        'save': True,  # Сохранять ли модель
        'save_period': 10,  # Сохранять модель каждые 10 эпох
        'project': 'runs/train',  # Папка для сохранения результатов
        'name': 'yolov8m_car_damage',  # Имя эксперимента
        'exist_ok': True,  # Перезаписывать папку если существует
        'pretrained': True,  # Использовать предобученные веса
        'optimizer': 'auto',  # Автоматически выбрать лучший оптимизатор
        'lr0': 0.01,  # Начальная скорость обучения
        'lrf': 0.01,  # Финальная скорость обучения
        'weight_decay': 0.0005,  # Регуляризация чтобы не переобучаться
        'warmup_epochs': 3,  # Плавный старт обучения
        'warmup_momentum': 0.8,  # Параметр для плавного старта

        # Коэффициенты для разных типов ошибок
        'box': 7.5,  # Ошибка положения прямоугольника
        'cls': 0.5,  # Ошибка классификации объекта
        'dfl': 1.5,  # Ошибка распределения

        # Аугментация - искусственное увеличение данных
        # Поворот картинок для лучшего обучения
        'fliplr': 0.5,  # Вероятность отзеркаливания по горизонтали
        'flipud': 0.0,  # Вероятность отзеркаливания по вертикали (выключено)
        'mosaic': 1.0,  # Создание коллажей из 4 картинок
        'mixup': 0.15,  # Смешивание двух картинок
        'copy_paste': 0.3,  # Копирование объектов с одной картинки на другую
        'degrees': 10.0,  # Максимальный поворот в градусах
        'translate': 0.1,  # Максимальное смещение
        'scale': 0.5,  # Максимальное масштабирование
        'shear': 2.0,  # Максимальный сдвиг
        'perspective': 0.0,  # Перспективные искажения (выключено)

        # Изменение цветов для разнообразия данных
        'hsv_h': 0.015,  # Изменение оттенка
        'hsv_s': 0.7,  # Изменение насыщенности
        'hsv_v': 0.4,  # Изменение яркости
    }

    # Запускаем процесс обучения модели
    # Модель будет учиться распознавать повреждения автомобилей
    results = model.train(**training_config)

    # После обучения проверяем качество модели на тестовых данных
    # Тестовые данные модель не видела во время обучения
    metrics = model.val()

    # Выводим метрики качества
    # mAP - средняя точность (чем выше, тем лучше)
    print(f"mAP50-95: {metrics.box.map}")  # Средняя точность при разной строгости
    print(f"mAP50: {metrics.box.map50}")  # Точность при 50% пересечении с реальным объектом
    print(f"mAP75: {metrics.box.map75}")  # Точность при 75% пересечении

    # Путь где сохранится лучшая модель
    best_model_path = 'best_car_damage_model.pt'
    print(f"Training completed. Best model saved.")


# Стандартная проверка для запуска из командной строки
if __name__ == '__main__':
    main()